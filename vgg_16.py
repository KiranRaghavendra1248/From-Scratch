# -*- coding: utf-8 -*-
"""VGG-16.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_sIm2YYnlgRsor3OIsuiq81Je21-zEou
"""

import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms

VGG16=[64,64,'M',128,128,'M',256,256,256,'M',512,512,512,'M',512,512,512,'M']

class VGG_net(nn.Module):
  def __init__(self,in_channels=3,num_classes=1000):
    super(VGG_net,self).__init__()
    self.in_channels=in_channels
    self.num_classes=num_classes
    self.conv_layers=self.make_conv(VGG16)
    self.fc_layers=nn.Sequential(nn.Linear(512*7*7,4096),
                                 nn.ReLU(),
                                 nn.Dropout(p=0.5),
                                 nn.Linear(4096,4096),
                                 nn.ReLU(),
                                 nn.Dropout(p=0.5),
                                 nn.Linear(4096,num_classes))
  def forward(self,x):
    x=self.conv_layers(x)
    x=x.reshape(x.shape[0],-1)
    x=self.fc_layers(x)
    return x

  def make_conv(self,architecture):
    layers=[]
    in_channels=self.in_channels
    for x in architecture:
      if type(x)==int:
        out_channels=x
        layers+=[nn.Conv2d(in_channels=in_channels,
                          out_channels=out_channels,
                          kernel_size=(3,3),stride=(1,1),
                          padding=(1,1)),
                          nn.BatchNorm2d(out_channels),
                          nn.ReLU()]
        in_channels=x
      elif x=='M':
        layers+=[nn.MaxPool2d(kernel_size=2,
                              stride=2)]

    return nn.Sequential(*layers)

model=VGG_net()
demo_tensor=torch.randn(1,3,224,224)
output_tensor=model(demo_tensor)
print(output_tensor.shape)

